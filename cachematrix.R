## The two functions written below take in either a matrix or in case of the second one
## a list containing the matrix to be inverted. The functions  
## return a list containing the matrix and its inverse

## This function takes in a numeric matrix as its input. It checks for invertibility
## first and returns an error message if the matrix is not. Upon passing the test
## the matrix inverse is calculated using a standard R function and a list created
## containing both the matrix and its inverse

makeCacheMatrix <- function(n = numeric()) 
  { x = as.matrix(n)  
    if ((nrow(x)!=ncol(x))||(det(x)==0)) return("Invalid matrix input")
      else 
        {inv <- solve(x)
         return(list(matrix = x,inverse = inv))
        }
  }


## The function takes in a numeric argument that could either be a matrix or a list
## containing either only the matrix or the matrix and its cached inverse. It checks
## what the entry is and then carries out the necessary operation for each.

cacheSolve <- function(m=numeric()) 
  {
  if (is.list(m)==TRUE)   #Checking if it's a list as generated by the previous function
  {if (!is.null(m$inverse)) 
  {print("Precalculated. Retrieving value....") #Retrieves cache
   return(list(matrix = m$matrix,inverse = m$inverse))}
  else
  { mat <- matrix(m$matrix) #If the list contains only the matrix but not its inverse
    m$inverse <- solve(mat) 
    return(t)}}
  else
  {   #If the input is a matrix
    if ((nrow(m)!=ncol(m))||(det(m)==0)) return("Invalid input") #CHecking invertibility again
    if(exists("makeCacheMatrix",mode="function")) inv = makeCacheMatrix(m) #Checking if the 
    #function has already been called into memory
    else inv = solve(m)
    return(list(matrix = m, inverse = inv))}
   }
